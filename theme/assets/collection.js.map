{"version":3,"sources":["node_modules/@bikeshaving/crank/cjs/crank.js","node_modules/@bikeshaving/crank/cjs/dom.js","node_modules/@bikeshaving/crank/cjs/index.js","node_modules/regenerator-runtime/runtime.js","app/bar-loader.js","app/error.js","app/fetch.js","app/select-menu.js","app/standalone/collection.js","app/text-button.js"],"names":["BarLoader","ErrorMsg","msg","toString","err","Fetch","src","console","log","fetch","then","response","status","Error","JSON","json","stringify","error","Object","prototype","hasOwnProperty","call","PostFetch","data","headers","formdata","opts","method","body","SelectMenu","id","active","title","menu","children","type","startsWith","map","el","idx","arr","text","item","BoxContent","productJson","idMap","baseUrl","menuSelectDate","fetchError","loading","fetchJson","fetchDates","includedProducts","handleMouseUp","ev","target","tagName","refresh","getAttribute","date","selectedDate","addEventListener","customizeBox","window","location","url","Date","parse","getData","keys","shopify_title","replace","length","toLowerCase","document","content","querySelectorAll","forEach","parentNode","querySelector","textContent","renderer","render","TextButton","index","array","name","position","borders","slug"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACniDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACzuBA;;AARA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMA,SAAS,GAAG,SAAZA,SAAY;AAAA,SAChB;AAAK,aAAM;AAAX,KACE;AAAM,aAAM;AAAZ,KACE;AAAM,aAAM;AAAZ,IADF,CADF,CADgB;AAAA,CAAlB;;eAQeA,S;;;;;;;;;;;;AClBf;;;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","file":"theme/assets/collection.js","sourcesContent":["\nrequire.register(\"@bikeshaving/crank/cjs/crank.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"@bikeshaving/crank\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst NOOP = () => { };\r\nfunction wrap(value) {\r\n    return value === undefined ? [] : Array.isArray(value) ? value : [value];\r\n}\r\nfunction unwrap(arr) {\r\n    return arr.length === 0 ? undefined : arr.length === 1 ? arr[0] : arr;\r\n}\r\n/**\r\n * Ensures a value is an array.\r\n *\r\n * This function does the same thing as wrap() above except it handles nulls\r\n * and iterables, so it is appropriate for wrapping user-provided children.\r\n */\r\nfunction arrayify(value) {\r\n    return value == null\r\n        ? []\r\n        : Array.isArray(value)\r\n            ? value\r\n            : typeof value === \"string\" ||\r\n                typeof value[Symbol.iterator] !== \"function\"\r\n                ? [value]\r\n                : [...value];\r\n}\r\nfunction isIteratorLike(value) {\r\n    return value != null && typeof value.next === \"function\";\r\n}\r\nfunction isPromiseLike(value) {\r\n    return value != null && typeof value.then === \"function\";\r\n}\r\n/***\r\n * SPECIAL TAGS\r\n *\r\n * Crank provides a couple tags which have special meaning for the renderer.\r\n ***/\r\n/**\r\n * A special tag for grouping multiple children within the same parent.\r\n *\r\n * All non-string iterables which appear in the element tree are implicitly\r\n * wrapped in a fragment element.\r\n *\r\n * This tag is just the empty string, and you can use the empty string in\r\n * createElement calls or transpiler options to avoid having to reference this\r\n * export directly.\r\n */\r\nconst Fragment = \"\";\r\n// TODO: We assert the following symbol tags as any because typescript support\r\n// for symbol tags in JSX doesn’t exist yet.\r\n// https://github.com/microsoft/TypeScript/issues/38367\r\n/**\r\n * A special tag for rendering into a root node passed via a root prop.\r\n *\r\n * This tag is useful for creating element trees with multiple roots, for\r\n * things like modals or tooltips.\r\n *\r\n * Renderer.prototype.render will implicitly wrap passed in element trees in an\r\n * implicit Portal element.\r\n */\r\nconst Portal = Symbol.for(\"crank.Portal\");\r\n/**\r\n * A special tag which preserves whatever was previously rendered in the\r\n * element’s position.\r\n *\r\n * Copy elements are useful for when you want to prevent a subtree from\r\n * rerendering as a performance optimization. Copy elements can also be keyed,\r\n * in which case the previously rendered keyed element will be preserved.\r\n */\r\nconst Copy = Symbol.for(\"crank.Copy\");\r\n/**\r\n * A special tag for injecting raw nodes or strings via a value prop.\r\n *\r\n * If the value prop is a string, Renderer.prototype.parse() will be called on\r\n * the string and the result of that method will be inserted.\r\n */\r\nconst Raw = Symbol.for(\"crank.Raw\");\r\nconst ElementSymbol = Symbol.for(\"crank.Element\");\r\n/*** ELEMENT FLAGS ***/\r\n/**\r\n * A flag which is set when the element is mounted, used to detect whether an\r\n * element is being reused so that we clone it rather than accidentally\r\n * overwriting its state.\r\n *\r\n * IMPORTANT: Changing this flag value would likely be a breaking changes in terms\r\n * of interop between elements created by different versions of Crank.\r\n */\r\nconst IsInUse = 1 << 0;\r\n/**\r\n * A flag which tracks whether the element has previously rendered children,\r\n * used to clear elements which no longer render children in the next render.\r\n * We may deprecate this and make elements without explicit children\r\n * uncontrolled.\r\n */\r\nconst HadChildren = 1 << 1;\r\n// To save on filesize, we mangle the internal properties of Crank classes by\r\n// hand. These internal properties are prefixed with an underscore. Refer to\r\n// their definitions to see their unabbreviated names.\r\n/**\r\n * Elements are the basic building blocks of Crank applications. They are\r\n * JavaScript objects which are interpreted by special classes called renderers\r\n * to produce and manage stateful nodes.\r\n *\r\n * @template {Tag} [TTag=Tag] - The type of the tag of the element.\r\n *\r\n * @example\r\n * // specific element types\r\n * let div: Element<\"div\">;\r\n * let portal: Element<Portal>;\r\n * let myEl: Element<MyComponent>;\r\n *\r\n * // general element types\r\n * let host: Element<string | symbol>;\r\n * let component: Element<Component>;\r\n *\r\n * Typically, you use a helper function like createElement to create elements\r\n * rather than instatiating this class directly.\r\n */\r\nclass Element {\r\n    constructor(tag, props, key, ref) {\r\n        this._f = 0;\r\n        this.tag = tag;\r\n        this.props = props;\r\n        this.key = key;\r\n        this.ref = ref;\r\n        this._ch = undefined;\r\n        this._n = undefined;\r\n        this._fb = undefined;\r\n        this._ic = undefined;\r\n        this._ov = undefined;\r\n    }\r\n    get hadChildren() {\r\n        return (this._f & HadChildren) !== 0;\r\n    }\r\n}\r\nElement.prototype.$$typeof = ElementSymbol;\r\nfunction isElement(value) {\r\n    return value != null && value.$$typeof === ElementSymbol;\r\n}\r\n/**\r\n * Creates an element with the specified tag, props and children.\r\n *\r\n * This function is usually used as a transpilation target for JSX transpilers,\r\n * but it can also be called directly. It additionally extracts the crank-key\r\n * and crank-ref props so they aren’t accessible to renderer methods or\r\n * components, and assigns the children prop according to any additional\r\n * arguments passed to the function.\r\n */\r\nfunction createElement(tag, props, ...children) {\r\n    let key;\r\n    let ref;\r\n    const props1 = {};\r\n    if (props != null) {\r\n        for (const name in props) {\r\n            switch (name) {\r\n                case \"crank-key\":\r\n                    // We have to make sure we don’t assign null to the key because we\r\n                    // don’t check for null keys in the diffing functions.\r\n                    if (props[\"crank-key\"] != null) {\r\n                        key = props[\"crank-key\"];\r\n                    }\r\n                    break;\r\n                case \"crank-ref\":\r\n                    if (typeof props[\"crank-ref\"] === \"function\") {\r\n                        ref = props[\"crank-ref\"];\r\n                    }\r\n                    break;\r\n                default:\r\n                    props1[name] = props[name];\r\n            }\r\n        }\r\n    }\r\n    if (children.length > 1) {\r\n        props1.children = children;\r\n    }\r\n    else if (children.length === 1) {\r\n        props1.children = children[0];\r\n    }\r\n    return new Element(tag, props1, key, ref);\r\n}\r\n/**\r\n * Clones a given element, shallowly copying the props object.\r\n *\r\n * Used internally to make sure we don’t accidentally reuse elements when\r\n * rendering.\r\n */\r\nfunction cloneElement(el) {\r\n    if (!isElement(el)) {\r\n        throw new TypeError(\"Cannot clone non-element\");\r\n    }\r\n    return new Element(el.tag, { ...el.props }, el.key, el.ref);\r\n}\r\nfunction narrow(value) {\r\n    if (typeof value === \"boolean\" || value == null) {\r\n        return undefined;\r\n    }\r\n    else if (typeof value === \"string\" || isElement(value)) {\r\n        return value;\r\n    }\r\n    else if (typeof value[Symbol.iterator] === \"function\") {\r\n        return createElement(Fragment, null, value);\r\n    }\r\n    return value.toString();\r\n}\r\n/**\r\n * Takes an array of element values and normalizes the output as an array of\r\n * nodes and strings.\r\n *\r\n * @returns Normalized array of nodes and/or strings.\r\n *\r\n * Normalize will flatten only one level of nested arrays, because it is\r\n * designed to be called once at each level of the tree. It will also\r\n * concatenate adjacent strings and remove all undefined values.\r\n */\r\nfunction normalize(values) {\r\n    const result = [];\r\n    let buffer;\r\n    for (let i = 0; i < values.length; i++) {\r\n        const value = values[i];\r\n        if (!value) ;\r\n        else if (typeof value === \"string\") {\r\n            buffer = (buffer || \"\") + value;\r\n        }\r\n        else if (!Array.isArray(value)) {\r\n            if (buffer) {\r\n                result.push(buffer);\r\n                buffer = undefined;\r\n            }\r\n            result.push(value);\r\n        }\r\n        else {\r\n            // We could use recursion here but it’s just easier to do it inline.\r\n            for (let j = 0; j < value.length; j++) {\r\n                const value1 = value[j];\r\n                if (!value1) ;\r\n                else if (typeof value1 === \"string\") {\r\n                    buffer = (buffer || \"\") + value1;\r\n                }\r\n                else {\r\n                    if (buffer) {\r\n                        result.push(buffer);\r\n                        buffer = undefined;\r\n                    }\r\n                    result.push(value1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (buffer) {\r\n        result.push(buffer);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Finds the value of the element according to its type.\r\n * @returns The value of the element.\r\n */\r\nfunction getValue(el) {\r\n    if (typeof el._fb !== \"undefined\") {\r\n        return typeof el._fb === \"object\" ? getValue(el._fb) : el._fb;\r\n    }\r\n    else if (el.tag === Portal) {\r\n        return undefined;\r\n    }\r\n    else if (typeof el.tag !== \"function\" && el.tag !== Fragment) {\r\n        return el._n;\r\n    }\r\n    return unwrap(getChildValues(el));\r\n}\r\nfunction getInflightValue(el) {\r\n    return ((typeof el.tag === \"function\" && el._n._iv) || el._ic || getValue(el));\r\n}\r\n/**\r\n * Walks an element’s children to find its child values.\r\n *\r\n * @returns A normalized array of nodes and strings.\r\n */\r\nfunction getChildValues(el) {\r\n    const values = [];\r\n    const children = wrap(el._ch);\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        if (child) {\r\n            values.push(typeof child === \"string\" ? child : getValue(child));\r\n        }\r\n    }\r\n    return normalize(values);\r\n}\r\n/**\r\n * An abstract class which is subclassed to render to different target\r\n * environments. This class is responsible for kicking off the rendering\r\n * process, caching previous trees by root, and creating, mutating and\r\n * disposing of nodes.\r\n *\r\n * @template TNode - The type of the node for a rendering environment.\r\n * @template TScope - Data which is passed down the tree.\r\n * @template TRoot - The type of the root for a rendering environment.\r\n * @template TResult - The type of exposed values.\r\n */\r\nclass Renderer {\r\n    constructor() {\r\n        this._cache = new WeakMap();\r\n    }\r\n    /**\r\n     * Renders an element tree into a specific root.\r\n     *\r\n     * @param children - An element tree. You can render null with a previously\r\n     * used root to delete the previously rendered element tree from the cache.\r\n     * @param root - The node to be rendered into. The renderer will cache\r\n     * element trees per root.\r\n     * @param ctx - An optional context that will be the ancestor context of all\r\n     * elements in the tree. Useful for connecting renderers which call each\r\n     * other so that events/provisions properly propagate. The context for a\r\n     * given root must be the same or an error will be thrown.\r\n     *\r\n     * @returns The result of rendering the children, or a possible promise of\r\n     * the result if the element tree renders asynchronously.\r\n     */\r\n    render(children, root, ctx) {\r\n        let portal;\r\n        if (typeof root === \"object\" && root !== null) {\r\n            portal = this._cache.get(root);\r\n        }\r\n        if (portal === undefined) {\r\n            portal = createElement(Portal, { children, root });\r\n            portal._n = ctx;\r\n            if (typeof root === \"object\" && root !== null && children != null) {\r\n                this._cache.set(root, portal);\r\n            }\r\n        }\r\n        else {\r\n            if (portal._n !== ctx) {\r\n                throw new Error(\"Context mismatch\");\r\n            }\r\n            portal.props = { children, root };\r\n            if (typeof root === \"object\" && root !== null && children == null) {\r\n                this._cache.delete(root);\r\n            }\r\n        }\r\n        const value = update(this, root, portal, ctx, undefined, portal);\r\n        // We return the child values of the portal because portal elements\r\n        // themselves have no readable value.\r\n        if (isPromiseLike(value)) {\r\n            return value.then(() => {\r\n                const result = this.read(unwrap(getChildValues(portal)));\r\n                if (root == null) {\r\n                    unmount(this, portal, undefined, portal);\r\n                }\r\n                return result;\r\n            });\r\n        }\r\n        const result = this.read(unwrap(getChildValues(portal)));\r\n        if (root == null) {\r\n            unmount(this, portal, undefined, portal);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Called when an element’s value is exposed via render, schedule, refresh,\r\n     * refs, or generator yield expressions.\r\n     *\r\n     * @param value - The value of the element being read. Can be a node, a\r\n     * string, undefined, or an array of nodes and strings, depending on the\r\n     * element.\r\n     *\r\n     * @returns Varies according to the specific renderer subclass. By default,\r\n     * it exposes the element’s value.\r\n     *\r\n     * This is useful for renderers which don’t want to expose their internal\r\n     * nodes. For instance, the HTML renderer will convert all internal nodes to\r\n     * strings.\r\n     *\r\n     */\r\n    read(value) {\r\n        return value;\r\n    }\r\n    /**\r\n     * Called in a preorder traversal for each host element.\r\n     *\r\n     * Useful for passing data down the element tree. For instance, the DOM\r\n     * renderer uses this method to keep track of whether we’re in an SVG\r\n     * subtree.\r\n     *\r\n     * @param el - The host element.\r\n     * @param scope - The current scope.\r\n     *\r\n     * @returns The scope to be passed to create and scope for child host\r\n     * elements.\r\n     *\r\n     * This method sets the scope for child host elements, not the current host\r\n     * element.\r\n     */\r\n    scope(_el, scope) {\r\n        return scope;\r\n    }\r\n    /**\r\n     * Called for each string in an element tree.\r\n     *\r\n     * @param text - The string child.\r\n     * @param scope - The current scope.\r\n     *\r\n     * @returns The escaped string.\r\n     *\r\n     * Rather than returning text nodes for whatever environment we’re rendering\r\n     * to, we defer that step for Renderer.prototype.arrange. We do this so that\r\n     * adjacent strings can be concatenated and the actual element tree can be\r\n     * rendered in a normalized form.\r\n     */\r\n    escape(text, _scope) {\r\n        return text;\r\n    }\r\n    /**\r\n     * Called for each Raw element whose value prop is a string.\r\n     *\r\n     * @param text - The string child.\r\n     * @param scope - The current scope.\r\n     *\r\n     * @returns The parsed node or string.\r\n     */\r\n    parse(text, _scope) {\r\n        return text;\r\n    }\r\n    /**\r\n     * Called for each host element when it is committed for the first time.\r\n     *\r\n     * @param el - The host element.\r\n     * @param scope - The current scope.\r\n     *\r\n     * @returns A “node” which determines the value of the host element.\r\n     */\r\n    create(_el, _scope) {\r\n        throw new Error(\"Not implemented\");\r\n    }\r\n    /**\r\n     * Called for each host element when it is committed.\r\n     *\r\n     * @param el - The host element.\r\n     * @param node - The node associated with the host element.\r\n     *\r\n     * @returns The return value is ignored.\r\n     *\r\n     * Used to mutate the node associated with an element when new props are\r\n     * passed.\r\n     */\r\n    patch(_el, _node) {\r\n        return;\r\n    }\r\n    // TODO: pass hints into arrange about where the dirty children start and end\r\n    /**\r\n     * Called for each host element so that elements can be arranged into a tree.\r\n     *\r\n     * @param el - The host element.\r\n     * @param node - The node associated with the host element.\r\n     * @param children - An array of nodes and strings from child elements.\r\n     *\r\n     * @returns The return value is ignored.\r\n     *\r\n     * This method is also called by child components contexts as the last step\r\n     * of a refresh.\r\n     */\r\n    arrange(_el, _node, _children) {\r\n        return;\r\n    }\r\n    // TODO: remove(): a method which is called to remove a child from a parent\r\n    // to optimize arrange\r\n    /**\r\n     * Called for each host element when it is unmounted.\r\n     *\r\n     * @param el - The host element.\r\n     * @param node - The node associated with the host element.\r\n     *\r\n     * @returns The return value is ignored.\r\n     */\r\n    dispose(_el, _node) {\r\n        return;\r\n    }\r\n    /**\r\n     * Called at the end of the rendering process for each root of the tree.\r\n     *\r\n     * @param root - The root prop passed to portals or the render method.\r\n     *\r\n     * @returns The return value is ignored.\r\n     */\r\n    complete(_root) {\r\n        return;\r\n    }\r\n}\r\n/*** PRIVATE RENDERER FUNCTIONS ***/\r\nfunction mount(renderer, root, host, ctx, scope, el) {\r\n    el._f |= IsInUse;\r\n    if (typeof el.tag === \"function\") {\r\n        el._n = new Context(renderer, root, host, ctx, scope, el);\r\n        return updateCtx(el._n);\r\n    }\r\n    else if (el.tag === Raw) {\r\n        return commit(renderer, scope, el, []);\r\n    }\r\n    else if (el.tag !== Fragment) {\r\n        if (el.tag === Portal) {\r\n            root = el.props.root;\r\n        }\r\n        else {\r\n            el._n = renderer.create(el, scope);\r\n            renderer.patch(el, el._n);\r\n        }\r\n        host = el;\r\n        scope = renderer.scope(host, scope);\r\n    }\r\n    return updateChildren(renderer, root, host, ctx, scope, el, el.props.children);\r\n}\r\nfunction update(renderer, root, host, ctx, scope, el) {\r\n    if (typeof el.tag === \"function\") {\r\n        return updateCtx(el._n);\r\n    }\r\n    else if (el.tag === Raw) {\r\n        return commit(renderer, scope, el, []);\r\n    }\r\n    else if (el.tag !== Fragment) {\r\n        if (el.tag === Portal) {\r\n            root = el.props.root;\r\n        }\r\n        else {\r\n            renderer.patch(el, el._n);\r\n        }\r\n        host = el;\r\n        scope = renderer.scope(host, scope);\r\n    }\r\n    return updateChildren(renderer, root, host, ctx, scope, el, el.props.children);\r\n}\r\nfunction createChildrenByKey(children) {\r\n    const childrenByKey = new Map();\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        if (typeof child === \"object\" && typeof child.key !== \"undefined\") {\r\n            childrenByKey.set(child.key, child);\r\n        }\r\n    }\r\n    return childrenByKey;\r\n}\r\nfunction updateChildren(renderer, root, host, ctx, scope, el, children) {\r\n    const oldChildren = wrap(el._ch);\r\n    const newChildren = arrayify(children);\r\n    const newChildren1 = [];\r\n    const values = [];\r\n    let graveyard;\r\n    let seenKeys;\r\n    let childrenByKey;\r\n    let isAsync = false;\r\n    let i = 0;\r\n    for (let j = 0, il = oldChildren.length, jl = newChildren.length; j < jl; j++) {\r\n        let oldChild = i >= il ? undefined : oldChildren[i];\r\n        let newChild = narrow(newChildren[j]);\r\n        // ALIGNMENT\r\n        let oldKey = typeof oldChild === \"object\" ? oldChild.key : undefined;\r\n        let newKey = typeof newChild === \"object\" ? newChild.key : undefined;\r\n        if (newKey !== undefined && seenKeys && seenKeys.has(newKey)) {\r\n            console.error(\"Duplicate key\", newKey);\r\n            newKey = undefined;\r\n        }\r\n        if (oldKey === newKey) {\r\n            if (childrenByKey !== undefined && newKey !== undefined) {\r\n                childrenByKey.delete(newKey);\r\n            }\r\n            i++;\r\n        }\r\n        else {\r\n            if (!childrenByKey) {\r\n                childrenByKey = createChildrenByKey(oldChildren.slice(i));\r\n            }\r\n            if (newKey === undefined) {\r\n                while (oldChild !== undefined && oldKey !== undefined) {\r\n                    i++;\r\n                    oldChild = oldChildren[i];\r\n                    oldKey = typeof oldChild === \"object\" ? oldChild.key : undefined;\r\n                }\r\n                i++;\r\n            }\r\n            else {\r\n                oldChild = childrenByKey.get(newKey);\r\n                if (oldChild !== undefined) {\r\n                    childrenByKey.delete(newKey);\r\n                }\r\n                if (!seenKeys) {\r\n                    seenKeys = new Set();\r\n                }\r\n                seenKeys.add(newKey);\r\n            }\r\n        }\r\n        // UPDATING\r\n        let value;\r\n        if (typeof oldChild === \"object\" &&\r\n            typeof newChild === \"object\" &&\r\n            oldChild.tag === newChild.tag) {\r\n            if (oldChild.tag === Portal &&\r\n                oldChild.props.root !== newChild.props.root) {\r\n                renderer.arrange(oldChild, oldChild.props.root, []);\r\n                renderer.complete(oldChild.props.root);\r\n            }\r\n            // TODO: implement Raw element parse caching\r\n            if (oldChild !== newChild) {\r\n                oldChild.props = newChild.props;\r\n                oldChild.ref = newChild.ref;\r\n                newChild = oldChild;\r\n            }\r\n            value = update(renderer, root, host, ctx, scope, newChild);\r\n        }\r\n        else if (typeof newChild === \"object\") {\r\n            if (newChild.tag === Copy) {\r\n                value =\r\n                    typeof oldChild === \"object\"\r\n                        ? getInflightValue(oldChild)\r\n                        : oldChild;\r\n                if (typeof newChild.ref === \"function\") {\r\n                    if (isPromiseLike(value)) {\r\n                        value.then(newChild.ref).catch(NOOP);\r\n                    }\r\n                    else {\r\n                        newChild.ref(value);\r\n                    }\r\n                }\r\n                newChild = oldChild;\r\n            }\r\n            else {\r\n                if (newChild._f & IsInUse) {\r\n                    newChild = cloneElement(newChild);\r\n                }\r\n                value = mount(renderer, root, host, ctx, scope, newChild);\r\n                if (isPromiseLike(value)) {\r\n                    newChild._fb = oldChild;\r\n                }\r\n            }\r\n        }\r\n        else if (typeof newChild === \"string\") {\r\n            newChild = value = renderer.escape(newChild, scope);\r\n        }\r\n        newChildren1[j] = newChild;\r\n        values[j] = value;\r\n        isAsync = isAsync || isPromiseLike(value);\r\n        if (typeof oldChild === \"object\" && oldChild !== newChild) {\r\n            if (!graveyard) {\r\n                graveyard = [];\r\n            }\r\n            graveyard.push(oldChild);\r\n        }\r\n    }\r\n    el._ch = unwrap(newChildren1);\r\n    // cleanup\r\n    for (; i < oldChildren.length; i++) {\r\n        const oldChild = oldChildren[i];\r\n        if (typeof oldChild === \"object\" && typeof oldChild.key === \"undefined\") {\r\n            if (!graveyard) {\r\n                graveyard = [];\r\n            }\r\n            graveyard.push(oldChild);\r\n        }\r\n    }\r\n    if (childrenByKey !== undefined && childrenByKey.size > 0) {\r\n        if (!graveyard) {\r\n            graveyard = [];\r\n        }\r\n        graveyard.push(...childrenByKey.values());\r\n    }\r\n    if (isAsync) {\r\n        let values1 = Promise.all(values).finally(() => {\r\n            if (graveyard) {\r\n                for (let i = 0; i < graveyard.length; i++) {\r\n                    unmount(renderer, host, ctx, graveyard[i]);\r\n                }\r\n            }\r\n        });\r\n        let onvalues;\r\n        values1 = Promise.race([\r\n            values1,\r\n            new Promise((resolve) => (onvalues = resolve)),\r\n        ]);\r\n        if (el._ov) {\r\n            el._ov(values1);\r\n        }\r\n        el._ic = values1.then((values) => commit(renderer, scope, el, normalize(values)));\r\n        el._ov = onvalues;\r\n        return el._ic;\r\n    }\r\n    if (graveyard) {\r\n        for (let i = 0; i < graveyard.length; i++) {\r\n            unmount(renderer, host, ctx, graveyard[i]);\r\n        }\r\n    }\r\n    if (el._ov) {\r\n        el._ov(values);\r\n        el._ov = undefined;\r\n    }\r\n    return commit(renderer, scope, el, normalize(values));\r\n}\r\nfunction commit(renderer, scope, el, values) {\r\n    if (el._ic) {\r\n        el._ic = undefined;\r\n    }\r\n    if (el._fb) {\r\n        el._fb = undefined;\r\n    }\r\n    let value;\r\n    if (typeof el.tag === \"function\") {\r\n        value = commitCtx(el._n, values);\r\n    }\r\n    else if (el.tag === Raw) {\r\n        if (typeof el.props.value === \"string\") {\r\n            el._n = renderer.parse(el.props.value, scope);\r\n        }\r\n        else {\r\n            el._n = el.props.value;\r\n        }\r\n        value = el._n;\r\n    }\r\n    else if (el.tag === Fragment) {\r\n        value = unwrap(values);\r\n    }\r\n    else {\r\n        if (el.tag === Portal) {\r\n            renderer.arrange(el, el.props.root, values);\r\n            renderer.complete(el.props.root);\r\n        }\r\n        else {\r\n            renderer.arrange(el, el._n, values);\r\n        }\r\n        value = el._n;\r\n        if (values.length) {\r\n            el._f |= HadChildren;\r\n        }\r\n        else {\r\n            el._f &= ~HadChildren;\r\n        }\r\n    }\r\n    if (el.ref) {\r\n        el.ref(renderer.read(value));\r\n    }\r\n    return value;\r\n}\r\nfunction unmount(renderer, host, ctx, el) {\r\n    if (typeof el.tag === \"function\") {\r\n        unmountCtx(el._n);\r\n        ctx = el._n;\r\n    }\r\n    else if (el.tag === Portal) {\r\n        host = el;\r\n        renderer.arrange(host, host.props.root, []);\r\n        renderer.complete(host.props.root);\r\n    }\r\n    else if (el.tag !== Fragment) {\r\n        if (isEventTarget(el._n)) {\r\n            const listeners = getListeners(ctx, host);\r\n            for (let i = 0; i < listeners.length; i++) {\r\n                const record = listeners[i];\r\n                el._n.removeEventListener(record.type, record.callback, record.options);\r\n            }\r\n        }\r\n        host = el;\r\n        renderer.dispose(host, host._n);\r\n    }\r\n    const children = wrap(el._ch);\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        if (typeof child === \"object\") {\r\n            unmount(renderer, host, ctx, child);\r\n        }\r\n    }\r\n}\r\n/*** CONTEXT FLAGS ***/\r\n/**\r\n * A flag which is set when the component is being updated by the parent and\r\n * cleared when the component has committed. Used to determine whether the\r\n * nearest host ancestor needs to be rearranged.\r\n */\r\nconst IsUpdating = 1 << 0;\r\n/**\r\n * A flag which is set when the component function or generator is\r\n * synchronously executing. This flags is used to ensure that a component which\r\n * triggers a second update in the course of rendering does not cause an stack\r\n * overflow or a generator error.\r\n */\r\nconst IsExecuting = 1 << 1;\r\n/**\r\n * A flag used to make sure multiple values are not pulled from context prop\r\n * iterators without a yield.\r\n */\r\nconst IsIterating = 1 << 2;\r\n/**\r\n * A flag used by async generator components in conjunction with the\r\n * onavailable (_oa) callback to mark whether new props can be pulled via the\r\n * context async iterator. See the Symbol.asyncIterator method and the\r\n * resumeCtx function.\r\n */\r\nconst IsAvailable = 1 << 3;\r\n/**\r\n * A flag which is set when a generator components returns, i.e. the done\r\n * property on the generator is set to true or throws. Done components will\r\n * stick to their last rendered value and ignore further updates.\r\n */\r\nconst IsDone = 1 << 4;\r\n/**\r\n * A flag which is set when the component is unmounted. Unmounted components\r\n * are no longer in the element tree and cannot refresh or rerender.\r\n */\r\nconst IsUnmounted = 1 << 5;\r\n/**\r\n * A flag which indicates that the component is a sync generator component.\r\n */\r\nconst IsSyncGen = 1 << 6;\r\n/**\r\n * A flag which indicates that the component is an async generator component.\r\n */\r\nconst IsAsyncGen = 1 << 7;\r\nconst provisionMaps = new WeakMap();\r\nconst scheduleMap = new WeakMap();\r\nconst cleanupMap = new WeakMap();\r\n/**\r\n * A class which is instantiated and passed to every component as its this\r\n * value. Contexts form a tree just like elements and all components in the\r\n * element tree are connected via contexts. Components can use this tree to\r\n * communicate data upwards via events and downwards via provisions.\r\n *\r\n * @template [TProps=*] - The expected shape of the props passed to the\r\n * component. Used to strongly type the Context iterator methods.\r\n * @template [TResult=*] - The readable element value type. It is used in\r\n * places such as the return value of refresh and the argument passed to\r\n * schedule and cleanup callbacks.\r\n */\r\nclass Context {\r\n    /**\r\n     * @internal\r\n     * Contexts should never be instantiated directly.\r\n     */\r\n    constructor(renderer, root, host, parent, scope, el) {\r\n        this._f = 0;\r\n        this._re = renderer;\r\n        this._rt = root;\r\n        this._ho = host;\r\n        this._pa = parent;\r\n        this._sc = scope;\r\n        this._el = el;\r\n        this._it = undefined;\r\n        this._oa = undefined;\r\n        this._ib = undefined;\r\n        this._iv = undefined;\r\n        this._eb = undefined;\r\n        this._ev = undefined;\r\n    }\r\n    /**\r\n     * The current props of the associated element.\r\n     *\r\n     * Typically, you should read props either via the first parameter of the\r\n     * component or via the context iterator methods. This property is mainly for\r\n     * plugins or utilities which wrap contexts.\r\n     */\r\n    get props() {\r\n        return this._el.props;\r\n    }\r\n    /**\r\n     * The current value of the associated element.\r\n     *\r\n     * Typically, you should read values via refs, generator yield expressions,\r\n     * or the refresh, schedule or cleanup methods. This property is mainly for\r\n     * plugins or utilities which wrap contexts.\r\n     */\r\n    get value() {\r\n        return this._re.read(getValue(this._el));\r\n    }\r\n    *[Symbol.iterator]() {\r\n        while (!(this._f & IsDone)) {\r\n            if (this._f & IsIterating) {\r\n                throw new Error(\"Context iterated twice without a yield\");\r\n            }\r\n            else if (this._f & IsAsyncGen) {\r\n                throw new Error(\"Use for await…of in async generator components\");\r\n            }\r\n            this._f |= IsIterating;\r\n            yield this._el.props;\r\n        }\r\n    }\r\n    async *[Symbol.asyncIterator]() {\r\n        // We use a do while loop rather than a while loop to handle an edge case\r\n        // where an async generator component is unmounted synchronously.\r\n        do {\r\n            if (this._f & IsIterating) {\r\n                throw new Error(\"Context iterated twice without a yield\");\r\n            }\r\n            else if (this._f & IsSyncGen) {\r\n                throw new Error(\"Use for…of in sync generator components\");\r\n            }\r\n            this._f |= IsIterating;\r\n            if (this._f & IsAvailable) {\r\n                this._f &= ~IsAvailable;\r\n            }\r\n            else {\r\n                await new Promise((resolve) => (this._oa = resolve));\r\n                if (this._f & IsDone) {\r\n                    break;\r\n                }\r\n            }\r\n            yield this._el.props;\r\n        } while (!(this._f & IsDone));\r\n    }\r\n    /**\r\n     * Re-executes a component.\r\n     *\r\n     * @returns The rendered value of the component or a promise thereof if the\r\n     * component or its children execute asynchronously.\r\n     *\r\n     * The refresh method works a little differently for async generator\r\n     * components, in that it will resume the Context’s props async iterator\r\n     * rather than resuming execution. This is because async generator components\r\n     * are perpetually resumed independent of updates, and rely on the props\r\n     * async iterator to suspend.\r\n     */\r\n    refresh() {\r\n        if (this._f & IsUnmounted) {\r\n            console.error(\"Component is unmounted\");\r\n            return this._re.read(undefined);\r\n        }\r\n        else if (this._f & IsExecuting) {\r\n            console.error(\"Component is already executing\");\r\n            return this._re.read(undefined);\r\n        }\r\n        resumeCtx(this);\r\n        return this._re.read(runCtx(this));\r\n    }\r\n    /**\r\n     * Registers a callback which fires when the component commits. Will only\r\n     * fire once per callback and update.\r\n     */\r\n    schedule(callback) {\r\n        let callbacks = scheduleMap.get(this);\r\n        if (!callbacks) {\r\n            callbacks = new Set();\r\n            scheduleMap.set(this, callbacks);\r\n        }\r\n        callbacks.add(callback);\r\n    }\r\n    /**\r\n     * Registers a callback which fires when the component unmounts. Will only\r\n     * fire once per callback.\r\n     */\r\n    cleanup(callback) {\r\n        let callbacks = cleanupMap.get(this);\r\n        if (!callbacks) {\r\n            callbacks = new Set();\r\n            cleanupMap.set(this, callbacks);\r\n        }\r\n        callbacks.add(callback);\r\n    }\r\n    consume(key) {\r\n        for (let parent = this._pa; parent !== undefined; parent = parent._pa) {\r\n            const provisions = provisionMaps.get(parent);\r\n            if (provisions && provisions.has(key)) {\r\n                return provisions.get(key);\r\n            }\r\n        }\r\n    }\r\n    provide(key, value) {\r\n        let provisions = provisionMaps.get(this);\r\n        if (!provisions) {\r\n            provisions = new Map();\r\n            provisionMaps.set(this, provisions);\r\n        }\r\n        provisions.set(key, value);\r\n    }\r\n    addEventListener(type, listener, options) {\r\n        let listeners;\r\n        if (listener == null) {\r\n            return;\r\n        }\r\n        else {\r\n            const listeners1 = listenersMap.get(this);\r\n            if (listeners1) {\r\n                listeners = listeners1;\r\n            }\r\n            else {\r\n                listeners = [];\r\n                listenersMap.set(this, listeners);\r\n            }\r\n        }\r\n        options = normalizeOptions(options);\r\n        let callback;\r\n        if (typeof listener === \"object\") {\r\n            callback = () => listener.handleEvent.apply(listener, arguments);\r\n        }\r\n        else {\r\n            callback = listener;\r\n        }\r\n        const record = { type, callback, listener, options };\r\n        if (options.once) {\r\n            record.callback = function () {\r\n                const i = listeners.indexOf(record);\r\n                if (i !== -1) {\r\n                    listeners.splice(i, 1);\r\n                }\r\n                return callback.apply(this, arguments);\r\n            };\r\n        }\r\n        if (listeners.some((record1) => record.type === record1.type &&\r\n            record.listener === record1.listener &&\r\n            !record.options.capture === !record1.options.capture)) {\r\n            return;\r\n        }\r\n        listeners.push(record);\r\n        for (const value of getChildValues(this._el)) {\r\n            if (isEventTarget(value)) {\r\n                value.addEventListener(record.type, record.callback, record.options);\r\n            }\r\n        }\r\n    }\r\n    removeEventListener(type, listener, options) {\r\n        const listeners = listenersMap.get(this);\r\n        if (listener == null || listeners == null) {\r\n            return;\r\n        }\r\n        const options1 = normalizeOptions(options);\r\n        const i = listeners.findIndex((record) => record.type === type &&\r\n            record.listener === listener &&\r\n            !record.options.capture === !options1.capture);\r\n        if (i === -1) {\r\n            return;\r\n        }\r\n        const record = listeners[i];\r\n        listeners.splice(i, 1);\r\n        for (const value of getChildValues(this._el)) {\r\n            if (isEventTarget(value)) {\r\n                value.removeEventListener(record.type, record.callback, record.options);\r\n            }\r\n        }\r\n    }\r\n    dispatchEvent(ev) {\r\n        const path = [];\r\n        for (let parent = this._pa; parent !== undefined; parent = parent._pa) {\r\n            path.push(parent);\r\n        }\r\n        // We patch the stopImmediatePropagation method because ev.cancelBubble\r\n        // only informs us if stopPropagation was called and there are no\r\n        // properties which inform us if stopImmediatePropagation was called.\r\n        let immediateCancelBubble = false;\r\n        const stopImmediatePropagation = ev.stopImmediatePropagation;\r\n        setEventProperty(ev, \"stopImmediatePropagation\", () => {\r\n            immediateCancelBubble = true;\r\n            return stopImmediatePropagation.call(ev);\r\n        });\r\n        setEventProperty(ev, \"target\", this);\r\n        // The only possible errors in this block are errors thrown in callbacks,\r\n        // and dispatchEvent is designed to only these errors rather than throwing\r\n        // them. Therefore, we place all code in a try block, log errors in the\r\n        // catch block use unsafe return statement in the finally block.\r\n        //\r\n        // Each early return within the try block returns true because while the\r\n        // return value is overridden in the finally block, TypeScript\r\n        // (justifiably) does not recognize the unsafe return statement.\r\n        try {\r\n            setEventProperty(ev, \"eventPhase\", CAPTURING_PHASE);\r\n            for (let i = path.length - 1; i >= 0; i--) {\r\n                const target = path[i];\r\n                const listeners = listenersMap.get(target);\r\n                if (listeners) {\r\n                    setEventProperty(ev, \"currentTarget\", target);\r\n                    for (const record of listeners) {\r\n                        if (record.type === ev.type && record.options.capture) {\r\n                            record.callback.call(this, ev);\r\n                            if (immediateCancelBubble) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (ev.cancelBubble) {\r\n                    return true;\r\n                }\r\n            }\r\n            {\r\n                const listeners = listenersMap.get(this);\r\n                if (listeners) {\r\n                    setEventProperty(ev, \"eventPhase\", AT_TARGET);\r\n                    setEventProperty(ev, \"currentTarget\", this);\r\n                    for (const record of listeners) {\r\n                        if (record.type === ev.type) {\r\n                            record.callback.call(this, ev);\r\n                            if (immediateCancelBubble) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (ev.cancelBubble) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            if (ev.bubbles) {\r\n                setEventProperty(ev, \"eventPhase\", BUBBLING_PHASE);\r\n                for (let i = 0; i < path.length; i++) {\r\n                    const target = path[i];\r\n                    const listeners = listenersMap.get(target);\r\n                    if (listeners) {\r\n                        setEventProperty(ev, \"currentTarget\", target);\r\n                        for (const record of listeners) {\r\n                            if (record.type === ev.type && !record.options.capture) {\r\n                                record.callback.call(this, ev);\r\n                                if (immediateCancelBubble) {\r\n                                    return true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if (ev.cancelBubble) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch (err) {\r\n            console.error(err);\r\n        }\r\n        finally {\r\n            setEventProperty(ev, \"eventPhase\", NONE);\r\n            setEventProperty(ev, \"currentTarget\", null);\r\n            // eslint-disable-next-line no-unsafe-finally\r\n            return !ev.defaultPrevented;\r\n        }\r\n    }\r\n}\r\n/*** PRIVATE CONTEXT FUNCTIONS ***/\r\n/**\r\n * This function is responsible for executing the component and handling all\r\n * the different component types.\r\n *\r\n * @returns {[block, value]} A tuple where\r\n * block - A possible promise which represents the duration during which the\r\n * component is blocked from updating.\r\n * value - A possible promise resolving to the rendered value of children.\r\n *\r\n * Each component type will block according to the type of the component.\r\n * - Sync function components never block and will transparently pass updates\r\n * to children.\r\n * - Async function components and async generator components block while\r\n * executing itself, but will not block for async children.\r\n * - Sync generator components block while any children are executing, because\r\n * they are expected to only resume when they’ve actually rendered.\r\n */\r\nfunction stepCtx(ctx) {\r\n    const el = ctx._el;\r\n    if (ctx._f & IsDone) {\r\n        return [undefined, getValue(el)];\r\n    }\r\n    const initial = !ctx._it;\r\n    if (initial) {\r\n        try {\r\n            ctx._f |= IsExecuting;\r\n            clearEventListeners(ctx);\r\n            const result = el.tag.call(ctx, el.props);\r\n            if (isIteratorLike(result)) {\r\n                ctx._it = result;\r\n            }\r\n            else if (isPromiseLike(result)) {\r\n                // async function component\r\n                const result1 = result instanceof Promise ? result : Promise.resolve(result);\r\n                const value = result1.then((result) => updateCtxChildren(ctx, result));\r\n                return [result1, value];\r\n            }\r\n            else {\r\n                // sync function component\r\n                return [undefined, updateCtxChildren(ctx, result)];\r\n            }\r\n        }\r\n        finally {\r\n            ctx._f &= ~IsExecuting;\r\n        }\r\n    }\r\n    // The value passed back into the generator as the argument to the next\r\n    // method is a promise if an async generator component has async children.\r\n    // Sync generator components only resume when their children have fulfilled\r\n    // so ctx._el._ic (the element’s inflight children) will never be defined.\r\n    let oldValue;\r\n    if (initial) {\r\n        // The argument passed to the first call to next is ignored.\r\n        oldValue = undefined;\r\n    }\r\n    else if (ctx._el._ic) {\r\n        oldValue = ctx._el._ic.then(ctx._re.read, () => ctx._re.read(undefined));\r\n    }\r\n    else {\r\n        oldValue = ctx._re.read(getValue(el));\r\n    }\r\n    let iteration;\r\n    try {\r\n        ctx._f |= IsExecuting;\r\n        iteration = ctx._it.next(oldValue);\r\n    }\r\n    catch (err) {\r\n        ctx._f |= IsDone;\r\n        throw err;\r\n    }\r\n    finally {\r\n        ctx._f &= ~IsExecuting;\r\n    }\r\n    if (isPromiseLike(iteration)) {\r\n        // async generator component\r\n        if (initial) {\r\n            ctx._f |= IsAsyncGen;\r\n        }\r\n        const value = iteration.then((iteration) => {\r\n            if (!(ctx._f & IsIterating)) {\r\n                ctx._f &= ~IsAvailable;\r\n            }\r\n            ctx._f &= ~IsIterating;\r\n            if (iteration.done) {\r\n                ctx._f |= IsDone;\r\n            }\r\n            try {\r\n                const value = updateCtxChildren(ctx, iteration.value);\r\n                if (isPromiseLike(value)) {\r\n                    return value.catch((err) => handleChildError(ctx, err));\r\n                }\r\n                return value;\r\n            }\r\n            catch (err) {\r\n                return handleChildError(ctx, err);\r\n            }\r\n        }, (err) => {\r\n            ctx._f |= IsDone;\r\n            throw err;\r\n        });\r\n        return [iteration, value];\r\n    }\r\n    // sync generator component\r\n    if (initial) {\r\n        ctx._f |= IsSyncGen;\r\n    }\r\n    ctx._f &= ~IsIterating;\r\n    if (iteration.done) {\r\n        ctx._f |= IsDone;\r\n    }\r\n    let value;\r\n    try {\r\n        value = updateCtxChildren(ctx, iteration.value);\r\n        if (isPromiseLike(value)) {\r\n            value = value.catch((err) => handleChildError(ctx, err));\r\n        }\r\n    }\r\n    catch (err) {\r\n        value = handleChildError(ctx, err);\r\n    }\r\n    if (isPromiseLike(value)) {\r\n        return [value.catch(NOOP), value];\r\n    }\r\n    return [undefined, value];\r\n}\r\n/**\r\n * Called when the inflight block promise settles.\r\n */\r\nfunction advanceCtx(ctx) {\r\n    // _ib - inflightBlock\r\n    // _iv - inflightValue\r\n    // _eb - enqueuedBlock\r\n    // _ev - enqueuedValue\r\n    ctx._ib = ctx._eb;\r\n    ctx._iv = ctx._ev;\r\n    ctx._eb = undefined;\r\n    ctx._ev = undefined;\r\n    if (ctx._f & IsAsyncGen && !(ctx._f & IsDone)) {\r\n        runCtx(ctx);\r\n    }\r\n}\r\n/**\r\n * Enqueues and executes the component associated with the context.\r\n *\r\n * The functions stepCtx, advanceCtx and runCtx work together to implement the\r\n * async queueing behavior of components. The runCtx function calls the stepCtx\r\n * function, which returns two results in a tuple. The first result, called the\r\n * “block,” is a possible promise which represents the duration for which the\r\n * component is blocked from accepting new updates. The second result, called\r\n * the “value,” is the actual result of the update. The runCtx function caches\r\n * block/value from the stepCtx function on the context, according to whether\r\n * the component blocks. The “inflight” block/value properties are the\r\n * currently executing update, and the “enqueued” block/value properties\r\n * represent an enqueued next stepCtx. Enqueued steps are dequeued every time\r\n * the current block promise settles.\r\n */\r\nfunction runCtx(ctx) {\r\n    if (!ctx._ib) {\r\n        try {\r\n            const [block, value] = stepCtx(ctx);\r\n            if (block) {\r\n                ctx._ib = block\r\n                    .catch((err) => {\r\n                    if (!(ctx._f & IsUpdating)) {\r\n                        return propagateError(ctx._pa, err);\r\n                    }\r\n                })\r\n                    .finally(() => advanceCtx(ctx));\r\n                // stepCtx will only return a block if the value is asynchronous\r\n                ctx._iv = value;\r\n            }\r\n            return value;\r\n        }\r\n        catch (err) {\r\n            if (!(ctx._f & IsUpdating)) {\r\n                return propagateError(ctx._pa, err);\r\n            }\r\n            throw err;\r\n        }\r\n    }\r\n    else if (ctx._f & IsAsyncGen) {\r\n        return ctx._iv;\r\n    }\r\n    else if (!ctx._eb) {\r\n        let resolve;\r\n        ctx._eb = ctx._ib\r\n            .then(() => {\r\n            try {\r\n                const [block, value] = stepCtx(ctx);\r\n                resolve(value);\r\n                if (block) {\r\n                    return block.catch((err) => {\r\n                        if (!(ctx._f & IsUpdating)) {\r\n                            return propagateError(ctx._pa, err);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            catch (err) {\r\n                if (!(ctx._f & IsUpdating)) {\r\n                    return propagateError(ctx._pa, err);\r\n                }\r\n            }\r\n        })\r\n            .finally(() => advanceCtx(ctx));\r\n        ctx._ev = new Promise((resolve1) => (resolve = resolve1));\r\n    }\r\n    return ctx._ev;\r\n}\r\n/**\r\n * Called to make props available to the props async iterator for async\r\n * generator components.\r\n */\r\nfunction resumeCtx(ctx) {\r\n    if (ctx._oa) {\r\n        ctx._oa();\r\n        ctx._oa = undefined;\r\n    }\r\n    else {\r\n        ctx._f |= IsAvailable;\r\n    }\r\n}\r\nfunction updateCtx(ctx) {\r\n    ctx._f |= IsUpdating;\r\n    resumeCtx(ctx);\r\n    return runCtx(ctx);\r\n}\r\nfunction updateCtxChildren(ctx, children) {\r\n    return updateChildren(ctx._re, ctx._rt, ctx._ho, ctx, ctx._sc, ctx._el, narrow(children));\r\n}\r\nfunction commitCtx(ctx, values) {\r\n    if (ctx._f & IsUnmounted) {\r\n        return;\r\n    }\r\n    const listeners = listenersMap.get(ctx);\r\n    if (listeners && listeners.length) {\r\n        for (let i = 0; i < values.length; i++) {\r\n            const value = values[i];\r\n            if (isEventTarget(value)) {\r\n                for (let j = 0; j < listeners.length; j++) {\r\n                    const record = listeners[j];\r\n                    value.addEventListener(record.type, record.callback, record.options);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (!(ctx._f & IsUpdating)) {\r\n        const listeners = getListeners(ctx._pa, ctx._ho);\r\n        if (listeners.length) {\r\n            for (let i = 0; i < values.length; i++) {\r\n                const value = values[i];\r\n                if (isEventTarget(value)) {\r\n                    for (let j = 0; j < listeners.length; j++) {\r\n                        const record = listeners[j];\r\n                        value.addEventListener(record.type, record.callback, record.options);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        const host = ctx._ho;\r\n        const hostValues = getChildValues(host);\r\n        ctx._re.arrange(host, host.tag === Portal ? host.props.root : host._n, hostValues);\r\n        if (hostValues.length) {\r\n            host._f |= HadChildren;\r\n        }\r\n        else {\r\n            host._f &= ~HadChildren;\r\n        }\r\n        ctx._re.complete(ctx._rt);\r\n    }\r\n    ctx._f &= ~IsUpdating;\r\n    const value = unwrap(values);\r\n    const callbacks = scheduleMap.get(ctx);\r\n    if (callbacks && callbacks.size) {\r\n        // We must clear the set of callbacks before calling them, because a\r\n        // callback which refreshes the component would otherwise cause a stack\r\n        // overflow.\r\n        const callbacks1 = Array.from(callbacks);\r\n        callbacks.clear();\r\n        const value1 = ctx._re.read(value);\r\n        for (const callback of callbacks1) {\r\n            callback(value1);\r\n        }\r\n    }\r\n    return value;\r\n}\r\n// TODO: async unmounting\r\nfunction unmountCtx(ctx) {\r\n    ctx._f |= IsUnmounted;\r\n    clearEventListeners(ctx);\r\n    const callbacks = cleanupMap.get(ctx);\r\n    if (callbacks && callbacks.size) {\r\n        const value = ctx._re.read(getValue(ctx._el));\r\n        for (const cleanup of callbacks) {\r\n            cleanup(value);\r\n        }\r\n        callbacks.clear();\r\n    }\r\n    if (!(ctx._f & IsDone)) {\r\n        ctx._f |= IsDone;\r\n        resumeCtx(ctx);\r\n        if (ctx._it && typeof ctx._it.return === \"function\") {\r\n            try {\r\n                ctx._f |= IsExecuting;\r\n                const iteration = ctx._it.return();\r\n                if (isPromiseLike(iteration)) {\r\n                    iteration.catch((err) => propagateError(ctx._pa, err));\r\n                }\r\n            }\r\n            finally {\r\n                ctx._f &= ~IsExecuting;\r\n            }\r\n        }\r\n    }\r\n}\r\n/*** EVENT TARGET UTILITIES ***/\r\n// EVENT PHASE CONSTANTS\r\n// https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase\r\nconst NONE = 0;\r\nconst CAPTURING_PHASE = 1;\r\nconst AT_TARGET = 2;\r\nconst BUBBLING_PHASE = 3;\r\nconst listenersMap = new WeakMap();\r\nfunction normalizeOptions(options) {\r\n    if (typeof options === \"boolean\") {\r\n        return { capture: options };\r\n    }\r\n    else if (options == null) {\r\n        return {};\r\n    }\r\n    return options;\r\n}\r\nfunction isEventTarget(value) {\r\n    return (value != null &&\r\n        typeof value.addEventListener === \"function\" &&\r\n        typeof value.removeEventListener === \"function\" &&\r\n        typeof value.dispatchEvent === \"function\");\r\n}\r\nfunction setEventProperty(ev, key, value) {\r\n    Object.defineProperty(ev, key, { value, writable: false, configurable: true });\r\n}\r\n/**\r\n * A function to reconstruct an array of every listener given a context and a\r\n * host element.\r\n *\r\n * This function exploits the fact that contexts retain their nearest ancestor\r\n * host element. We can determine all the contexts which are directly listening\r\n * to an element by traversing up the context tree and checking that the host\r\n * element passed in matches the parent context’s host element.\r\n *\r\n * TODO: Maybe we can pass in the current context directly, rather than\r\n * starting from the parent?\r\n */\r\nfunction getListeners(ctx, host) {\r\n    let listeners = [];\r\n    while (ctx !== undefined && ctx._ho === host) {\r\n        const listeners1 = listenersMap.get(ctx);\r\n        if (listeners1) {\r\n            listeners = listeners.concat(listeners1);\r\n        }\r\n        ctx = ctx._pa;\r\n    }\r\n    return listeners;\r\n}\r\nfunction clearEventListeners(ctx) {\r\n    const listeners = listenersMap.get(ctx);\r\n    if (listeners && listeners.length) {\r\n        for (const value of getChildValues(ctx._el)) {\r\n            if (isEventTarget(value)) {\r\n                for (const record of listeners) {\r\n                    value.removeEventListener(record.type, record.callback, record.options);\r\n                }\r\n            }\r\n        }\r\n        listeners.length = 0;\r\n    }\r\n}\r\n/*** ERROR HANDLING UTILITIES ***/\r\n// TODO: generator components which throw errors should be recoverable\r\nfunction handleChildError(ctx, err) {\r\n    if (ctx._f & IsDone || !ctx._it || typeof ctx._it.throw !== \"function\") {\r\n        throw err;\r\n    }\r\n    resumeCtx(ctx);\r\n    let iteration;\r\n    try {\r\n        ctx._f |= IsExecuting;\r\n        iteration = ctx._it.throw(err);\r\n    }\r\n    catch (err) {\r\n        ctx._f |= IsDone;\r\n        throw err;\r\n    }\r\n    finally {\r\n        ctx._f &= ~IsExecuting;\r\n    }\r\n    if (isPromiseLike(iteration)) {\r\n        return iteration.then((iteration) => {\r\n            if (iteration.done) {\r\n                ctx._f |= IsDone;\r\n            }\r\n            return updateCtxChildren(ctx, iteration.value);\r\n        }, (err) => {\r\n            ctx._f |= IsDone;\r\n            throw err;\r\n        });\r\n    }\r\n    if (iteration.done) {\r\n        ctx._f |= IsDone;\r\n    }\r\n    return updateCtxChildren(ctx, iteration.value);\r\n}\r\nfunction propagateError(ctx, err) {\r\n    if (ctx === undefined) {\r\n        throw err;\r\n    }\r\n    let result;\r\n    try {\r\n        result = handleChildError(ctx, err);\r\n    }\r\n    catch (err) {\r\n        return propagateError(ctx._pa, err);\r\n    }\r\n    if (isPromiseLike(result)) {\r\n        return result.catch((err) => propagateError(ctx._pa, err));\r\n    }\r\n    return result;\r\n}\n\nexports.Context = Context;\nexports.Copy = Copy;\nexports.Element = Element;\nexports.Fragment = Fragment;\nexports.Portal = Portal;\nexports.Raw = Raw;\nexports.Renderer = Renderer;\nexports.cloneElement = cloneElement;\nexports.createElement = createElement;\nexports.isElement = isElement;\n//# sourceMappingURL=crank.js.map\n  })();\n});","\nrequire.register(\"@bikeshaving/crank/cjs/dom.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"@bikeshaving/crank\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar crank = require('./crank.js');\n\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\r\nclass DOMRenderer extends crank.Renderer {\r\n    render(children, root, ctx) {\r\n        if (root == null || typeof root.nodeType !== \"number\") {\r\n            throw new TypeError(`Render root is not a node. Received: ${JSON.stringify(root && root.toString())}`);\r\n        }\r\n        return super.render(children, root, ctx);\r\n    }\r\n    parse(text) {\r\n        if (typeof document.createRange === \"function\") {\r\n            return document.createRange().createContextualFragment(text);\r\n        }\r\n        else {\r\n            const fragment = document.createDocumentFragment();\r\n            const childNodes = new DOMParser().parseFromString(text, \"text/html\").body\r\n                .childNodes;\r\n            for (let i = 0; i < childNodes.length; i++) {\r\n                fragment.appendChild(childNodes[i]);\r\n            }\r\n            return fragment;\r\n        }\r\n    }\r\n    scope(el, scope) {\r\n        switch (el.tag) {\r\n            case crank.Portal:\r\n            case \"foreignObject\":\r\n                return undefined;\r\n            case \"svg\":\r\n                return SVG_NAMESPACE;\r\n            default:\r\n                return scope;\r\n        }\r\n    }\r\n    create(el, ns) {\r\n        if (typeof el.tag !== \"string\") {\r\n            throw new Error(`Unknown tag: ${el.tag.toString()}`);\r\n        }\r\n        else if (el.tag === \"svg\") {\r\n            ns = SVG_NAMESPACE;\r\n        }\r\n        return ns\r\n            ? document.createElementNS(ns, el.tag)\r\n            : document.createElement(el.tag);\r\n    }\r\n    patch(el, node) {\r\n        const isSVG = node.namespaceURI === SVG_NAMESPACE;\r\n        for (let name in el.props) {\r\n            let forceAttribute = false;\r\n            const value = el.props[name];\r\n            switch (name) {\r\n                case \"children\":\r\n                    break;\r\n                case \"style\": {\r\n                    const style = node.style;\r\n                    if (style == null) {\r\n                        node.setAttribute(\"style\", value);\r\n                    }\r\n                    else {\r\n                        if (value == null) {\r\n                            node.removeAttribute(\"style\");\r\n                        }\r\n                        else if (typeof value === \"string\") {\r\n                            if (style.cssText !== value) {\r\n                                style.cssText = value;\r\n                            }\r\n                        }\r\n                        else {\r\n                            for (const styleName in value) {\r\n                                const styleValue = value && value[styleName];\r\n                                if (styleValue == null) {\r\n                                    style.removeProperty(styleName);\r\n                                }\r\n                                else if (style.getPropertyValue(styleName) !== styleValue) {\r\n                                    style.setProperty(styleName, styleValue);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case \"class\":\r\n                case \"className\":\r\n                    if (value === true) {\r\n                        node.setAttribute(\"class\", \"\");\r\n                    }\r\n                    else if (!value) {\r\n                        node.removeAttribute(\"class\");\r\n                    }\r\n                    else if (!isSVG) {\r\n                        if (node.className !== value) {\r\n                            node[\"className\"] = value;\r\n                        }\r\n                    }\r\n                    else if (node.getAttribute(\"class\") !== value) {\r\n                        node.setAttribute(\"class\", value);\r\n                    }\r\n                    break;\r\n                // Gleaned from:\r\n                // https://github.com/preactjs/preact/blob/05e5d2c0d2d92c5478eeffdbd96681c96500d29f/src/diff/props.js#L111-L117\r\n                // TODO: figure out why we use setAttribute for each of these\r\n                case \"form\":\r\n                case \"list\":\r\n                case \"type\":\r\n                case \"size\":\r\n                    forceAttribute = true;\r\n                // fallthrough\r\n                default: {\r\n                    if (value == null) {\r\n                        node.removeAttribute(name);\r\n                    }\r\n                    else if (typeof value === \"function\" ||\r\n                        typeof value === \"object\" ||\r\n                        (!forceAttribute && !isSVG && name in node)) {\r\n                        if (node[name] !== value) {\r\n                            node[name] = value;\r\n                        }\r\n                    }\r\n                    else if (value === true) {\r\n                        node.setAttribute(name, \"\");\r\n                    }\r\n                    else if (value === false) {\r\n                        node.removeAttribute(name);\r\n                    }\r\n                    else if (node.getAttribute(name) !== value) {\r\n                        node.setAttribute(name, value);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    arrange(el, node, children) {\r\n        if (el.tag === crank.Portal &&\r\n            (node == null || typeof node.nodeType !== \"number\")) {\r\n            throw new TypeError(`Portal root is not a node. Received: ${JSON.stringify(node && node.toString())}`);\r\n        }\r\n        if (!(\"innerHTML\" in el.props) &&\r\n            (\"children\" in el.props || el.hadChildren)) {\r\n            if (children.length === 0) {\r\n                node.textContent = \"\";\r\n            }\r\n            else {\r\n                let oldChild = node.firstChild;\r\n                let i = 0;\r\n                while (oldChild !== null && i < children.length) {\r\n                    const newChild = children[i];\r\n                    if (oldChild === newChild) {\r\n                        oldChild = oldChild.nextSibling;\r\n                        i++;\r\n                    }\r\n                    else if (typeof newChild === \"string\") {\r\n                        if (oldChild.nodeType === Node.TEXT_NODE) {\r\n                            if (oldChild.data !== newChild) {\r\n                                oldChild.data = newChild;\r\n                            }\r\n                            oldChild = oldChild.nextSibling;\r\n                        }\r\n                        else {\r\n                            node.insertBefore(document.createTextNode(newChild), oldChild);\r\n                        }\r\n                        i++;\r\n                    }\r\n                    else if (oldChild.nodeType === Node.TEXT_NODE) {\r\n                        const nextSibling = oldChild.nextSibling;\r\n                        node.removeChild(oldChild);\r\n                        oldChild = nextSibling;\r\n                    }\r\n                    else {\r\n                        node.insertBefore(newChild, oldChild);\r\n                        i++;\r\n                        // TODO: This is an optimization but we need to think a little more about other cases like prepending.\r\n                        if (oldChild !== children[i]) {\r\n                            const nextSibling = oldChild.nextSibling;\r\n                            node.removeChild(oldChild);\r\n                            oldChild = nextSibling;\r\n                        }\r\n                    }\r\n                }\r\n                while (oldChild !== null) {\r\n                    const nextSibling = oldChild.nextSibling;\r\n                    node.removeChild(oldChild);\r\n                    oldChild = nextSibling;\r\n                }\r\n                for (; i < children.length; i++) {\r\n                    const newChild = children[i];\r\n                    node.appendChild(typeof newChild === \"string\"\r\n                        ? document.createTextNode(newChild)\r\n                        : newChild);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nconst renderer = new DOMRenderer();\n\nexports.DOMRenderer = DOMRenderer;\nexports.renderer = renderer;\n//# sourceMappingURL=dom.js.map\n  })();\n});","\nrequire.register(\"@bikeshaving/crank/cjs/index.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"@bikeshaving/crank\");\n  (function() {\n    'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar crank = require('./crank.js');\n\n\n\nexports.Context = crank.Context;\nexports.Copy = crank.Copy;\nexports.Element = crank.Element;\nexports.Fragment = crank.Fragment;\nexports.Portal = crank.Portal;\nexports.Raw = crank.Raw;\nexports.Renderer = crank.Renderer;\nexports.cloneElement = crank.cloneElement;\nexports.createElement = crank.createElement;\nexports.isElement = crank.isElement;\n//# sourceMappingURL=index.js.map\n  })();\n});","\nrequire.register(\"regenerator-runtime/runtime.js\", function(exports, require, module) {\n  require = __makeRelativeRequire(require, {}, \"regenerator-runtime\");\n  (function() {\n    /**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n  })();\n});","/** @jsx createElement */\n/**\n * Loading indicator module\n *\n * @module app/lib/bar-loader\n * @exports {Element} BarLoader\n * @author Darryl Cousins <darryljcousins@gmail.com>\n */\nimport { createElement } from \"@bikeshaving/crank/cjs\";\n\n/**\n * Loader component\n *\n * @returns {Element} DOM component\n * @example\n * { loading && <BarLoader /> }\n */\nconst BarLoader = () => (\n  <div class=\"progress-bar mt2\">\n    <span class=\"bar\">\n      <span class=\"progress\" />\n    </span>\n  </div>\n);\n\nexport default BarLoader;\n\n","/** @jsx createElement */\n/**\n * Error display component module\n *\n * @module app/lib/error\n * @author Darryl Cousins <darryljcousins@gmail.com>\n */\nimport { createElement, isElement } from \"@bikeshaving/crank/cjs\";\n\n/**\n * Error component\n *\n * @returns {Element} DOM component\n * @param {object} props  Component properties\n * @param {Element|string|object} props.msg Error to be displayed\n * @example\n * { error && <ErrorMsg msg=\"Some error message\" /> }\n */\nconst ErrorMsg = ({ msg }) => {\n  // console.log(msg, typeof msg, isElement(msg));\n  if (typeof msg === \"string\" || isElement(msg)) {\n    return (\n      <div class=\"dark-red mv2 pt2 pl2 br3 ba b--dark-red bg-washed-red\">\n        <p class=\"tc\">{msg}</p>\n      </div>\n    );\n  }\n\n  if (typeof msg === \"object\" || !msg.msg) {\n    return (\n      <div class=\"dark-red mv2 pt2 pl2 br3 ba b--dark-red bg-washed-red\">\n        <p class=\"tc\">{msg.toString()}</p>\n      </div>\n    );\n  }\n\n  return (\n    <div class=\"dark-red mv2 pt2 pl2 br3 ba b--dark-red bg-washed-red\">\n      <p class=\"tc\">\n        {msg.msg}:{msg.err}\n      </p>\n    </div>\n  );\n};\n\nexport default ErrorMsg;\n\n","/**\n * Fetch components\n *\n * @module app/lib/fetch\n * @author Darryl Cousins <darryljcousins@gmail.com>\n */\n\n/**\n * Fetch component that attempts to deal reasonably if the fetch fails. Always\n * uses a `GET` request` and expects a `json` response.\n *\n * @returns {Promise} A promise resolving to { error, json }\n * @param {string} src Url to send request\n * @example\n * const src\n * Fetch(src)\n *   .then((result) => {\n *     const { error, json } = result;\n *   })\n */\nconst Fetch = async (src) => {\n  console.log('fetching', src);\n  return fetch(src)\n    .then(async (response) => {\n      if (response.status !== 200) {\n        throw new Error(JSON.stringify(await response.json()));\n      }\n      return response.json();\n    })\n    .then((json) => {\n      console.log(\"Got this in GET fetch:\", json);\n      return { error: null, json };\n    })\n    .catch((error) => {\n      console.log(\"Got error in GET fetch:\", error);\n      if (Object.prototype.hasOwnProperty.call(error, \"err\")) {\n        return { error: error.err, json: null };\n      }\n      return { error, json: null };\n    });\n};\n\n/**\n * PostFetch component that attempts to deal reasonably if the fetch fails. Always\n * uses a `POST` request` and expects a `json` response.\n *\n * @returns {Promise} A promise resolving to { error, json }\n * @param {object} opts Dicitonary of options\n * @param {string} opts.src Url to send request to\n * @param {string} opts.data Data to be sent with request\n * @param {string} opts.headers Headers to send data with, usually `{\"Content-Type\": \"application/json\"}` but not when uploading files.\n * @example\n * const src = \"api/create-todo\";\n * const data = {title: \"Fix me\"};\n * const headers = { \"Content-Type\": \"application/json\" };\n * PostFetch({src, data, headers})\n *   .then((result) => {\n *     const { error, json } = result;\n *   })\n */\nconst PostFetch = async ({ src, data, headers }) => {\n  // use json if according to content-type\n  const formdata =\n    headers[\"Content-Type\"] === \"application/json\"\n      ? JSON.stringify(data)\n      : data;\n\n  const opts = {\n    method: \"POST\",\n    body: formdata,\n  };\n\n  // add headers if set in arguments - i.e. using none if sending files\n  if (headers) opts.headers = headers;\n\n  return fetch(src, opts)\n    .then(async (response) => {\n      if (response.status !== 200) {\n        throw new Error(JSON.stringify(await response.json()));\n      }\n      console.log(\"Got this response in POST fetch\", response);\n      return response.json();\n    })\n    .then((json) => {\n      console.log(\"Got this in POST fetch:\", json);\n      return { error: null, json };\n    })\n    .catch((error) => {\n      console.log(\"Got error in POST fetch:\", error);\n      if (Object.prototype.hasOwnProperty.call(error, \"err\")) {\n        return { error: error.err, json: null };\n      }\n      return { error, json: null };\n    });\n};\n\nexport { Fetch, PostFetch };\n\n","/** @jsx createElement */\n/**\n * Component\n *\n * @module app/product-description\n * @exports {Element} SelectDeliveryDate\n * @author Darryl Cousins <darryljcousins@gmail.com>\n */\nimport { createElement, Fragment } from \"@bikeshaving/crank/cjs\";\nimport TextButton from \"./text-button.js\";\n\n/**\n * Component\n *\n * @returns {Element} DOM component\n * <SelectMenu id=\"selectDate\" menu={fetchDates} title=\"Select Date\" active={menuSelectDate} />\n */\nconst SelectMenu = ({ id, active, title, menu, children }) => {\n  const type = (id.startsWith(\"selectDate\")) ? \"ttu tracked\" : \"\";\n  return (\n    <Fragment>\n      <button\n        class={`dib w-100 f6 ${type} outline-0 gray b--gray ba ba1 bg-transparent br2 pa2 mb1 pointer`}\n        title={title}\n        id={id}\n        type=\"button\"\n        >\n        { children }\n      </button>\n      { active && (\n        <div class=\"absolute w-100 bg-white br2\">\n        {menu.map((el, idx, arr) => (\n          <TextButton text={el.text} index={idx} array={arr} name={id} item={el.item} />\n        ))}\n        </div>\n      )}\n    </Fragment>\n  )\n};\n\nexport default SelectMenu;\n","/** @jsx createElement */\n/**\n * Home page client app for collection listings\n *\n * @author Darryl Cousins <darryljcousins@gmail.com>\n * @module app/home-page\n * @requires @bikeshaving/crank\n * @listens DOMContentLoaded\n */\nimport \"regenerator-runtime/runtime\"; // regeneratorRuntime error\nimport { createElement, Fragment } from \"@bikeshaving/crank/cjs\";\nimport { renderer } from \"@bikeshaving/crank/cjs/dom\";\nimport { Fetch } from \"../fetch\";\nimport Error from \"../error\";\nimport BarLoader from \"../bar-loader\";\nimport SelectMenu from \"../select-menu\";\n\nfunction* BoxContent ({productJson}) {\n  const idMap = {\n    // small\n    \"6163982876822\": \"5571286728870\",\n    // med\n    \"6163982975126\": \"5571286794406\",\n    // med fruit\n    \"6163982844054\": \"5576573878438\",\n    // med bread\n    \"6163982942358\": \"5577031352486\",\n    // big\n    \"6163982680214\": \"5571286696102\",\n    // custom\n    \"6163982647446\": \"5598426005670\",\n  }\n  /**\n   * Base url to api\n   *\n   * @member baseUrl\n   * @type {string}\n   */\n  const baseUrl = \"https://streamsidedev.cousinsd.net/api/\";\n  /**\n   * The selected date after user select, one of fetchJson.keys\n   *\n   * @member selectedDate\n   * @type {string}\n   */\n  let selectedDate;\n  /**\n   * Display date selection menu if active\n   *\n   * @member menuSelectDate\n   * @type {boolean}\n   */\n  let menuSelectDate= false;\n  /**\n   * If fetching data was unsuccessful.\n   *\n   * @member fetchError\n   * @type {object|string|null}\n   */\n  let fetchError = null;\n  /**\n   * Display loading indicator while fetching data\n   *\n   * @member loading\n   * @type {boolean}\n   */\n  let loading = true;\n  /**\n   * Contains box data as collected from [api/current-boxes-by-product]{@link\n   * module:api/current-boxes-by-product}. The data uses delivery date as keys to unsorted\n   * array of box data.\n   *\n   * @member fetchJson\n   * @type {object}\n   */\n  let fetchJson = {};\n  /**\n   * Upcoming delivery dates\n   *\n   * @member fetchDates\n   * @type {object}\n   */\n  let fetchDates = [];\n  /**\n   * Included products - disregarding delivery date for now\n   *\n   * @member includedProducts\n   * @type {object}\n   */\n  let includedProducts = [];\n  /**\n   * Handle mouse up on selected components\n   *\n   * @function handleMouseUp\n   * @param {object} ev The firing event\n   * @listens click\n   */\n  const handleMouseUp = (ev) => {\n    if (ev.target.tagName === \"BUTTON\") {\n\n      switch(ev.target.id) {\n        case `selectDate${productJson.id}`:\n          menuSelectDate = !menuSelectDate;\n          this.refresh()\n          break;\n      }\n\n    } else if (ev.target.tagName === \"DIV\") {\n\n      switch(ev.target.getAttribute(\"name\")) {\n        case `selectDate${productJson.id}`:\n          const date = ev.target.getAttribute(\"data-item\");\n          selectedDate = date;\n          //selectBox(date);\n          menuSelectDate = false;\n          this.refresh()\n          break;\n      }\n    }\n  };\n\n  this.addEventListener(\"mouseup\", handleMouseUp);\n\n  /**\n   * Customize box clicked\n   *\n   * @function customizeBox\n   */\n  const customizeBox = () => {\n    console.log(selectedDate, productJson.id);\n    window.location = `${productJson.url}?${Date.parse(selectedDate)}`;\n  };\n\n  /**\n   * Gather box includes for display, watch for dates\n   *\n   * @function selectBox\n   * @param date {string} The selected date\n   */\n  const getData = async () => {\n    await Fetch(`${baseUrl}current-boxes-by-product/${idMap[productJson.id]}`)\n      .then(({error, json}) => {\n        if (error) {\n          fetchError = error;\n        } else {\n          fetchDates = Object.keys(json);\n          includedProducts = json[fetchDates[0]].includedProducts.map(el => el.shopify_title.replace(/^- ?/, \"\"));\n          fetchJson = json;\n        }\n        loading = false;\n        this.refresh();\n      })\n  };\n\n  // get loaded\n  getData();\n\n  while(true) {\n    yield (\n      <Fragment>\n        { fetchError && <Error msg={fetchError} /> }\n        { loading ? <BarLoader /> : (\n          <Fragment>\n            <div class=\"w-100 pv2\">\n              { !includedProducts.length ? (\n                <div>Build your own box with available products.</div>\n              ) : (\n                includedProducts.map(el => (\n                  <a\n                    href={`/products/${el.replace(/ /g, '-').toLowerCase()}`}\n                    class=\"link pointer o-90 fl f6 ph3 ma1 ba br-pill b--streamside-blue bg-transparent fg-streamside-blue\"\n                  >\n                      { el }\n                  </a>\n              )))}\n            </div>\n            <div class=\"cf\" />\n            { fetchDates.length && (\n              <Fragment>\n                <div class=\"relative w-100 pt3-ns cf\">\n                  <div class={selectedDate ? \"w-100 w-third-ns fl\" : \"w-100 fl\"}>\n                    <SelectMenu\n                      id={`selectDate${productJson.id}`}\n                      menu={fetchDates.map(el => ({text: el, item: el}))}\n                      title=\"Select Date\"\n                      active={menuSelectDate}\n                    >\n                      { selectedDate ? selectedDate : \"Select delivery date\" }&nbsp;&nbsp;&nbsp;&#9662;\n                    </SelectMenu>\n                  </div>\n                  { selectedDate && (\n                    <Fragment>\n                      <div class=\"w-100 w-third-ns fl pl1\">\n                        <button\n                          type=\"button\"\n                          name=\"add\"\n                          aria-label=\"Add to cart\"\n                          class=\"di f6 ttu w-100 tracked dim outline-0 debut-yellow b--debut-brown ba ba1 bg-debut-brown br2 pa2 mb1 pointer\"\n                        >\n                            Add to cart\n                        </button>\n                      </div>\n                      <div class=\"w-100 w-third-ns fl pl1\">\n                        <button\n                          type=\"button\"\n                          name=\"customize\"\n                          aria-label=\"Customize box\"\n                          class=\"di f6 ttu w-100 tracked dim outline-0 debut-yellow b--debut-brown ba ba1 bg-debut-brown br2 pa2 mb1 pointer\"\n                          onclick={customizeBox}\n                        >\n                          Customize box\n                        </button>\n                      </div>\n                    </Fragment>\n                  )}\n                </div>\n              </Fragment>\n            )}\n\n          </Fragment>\n        )}\n      </Fragment>\n    );\n  };\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", async () => {\n  // do your setup here\n  const content = document.querySelectorAll(\"p[name='box-content']\");\n  content.forEach(async el => {\n    const json = JSON.parse(el.parentNode.querySelector(\"script\").textContent);\n    await renderer.render(<BoxContent productJson={json} />, el);\n  });\n});\n\n","/** @jsx createElement */\n/**\n *\n * @module app/form/filter-select\n * @author Darryl Cousins <darryljcousins@gmail.com>\n */\nimport { createElement } from \"@bikeshaving/crank/cjs\";\n\n/**\n * Renders a select field for generating filters\n *\n * @generator\n * @param {object} props The property object\n * @param {string} props.text The display text - will be slugified to create name/id\n * @param {number} props.index The index of the menu array - used to add borders and border radius to group multiple items\n * @param {array} props.array The menu array that this is a part of\n * @param {string} props.title Text used for visual hint on hover\n * @param {string} props.name Used to identify the action when listening for click on the component\n * @param {string|number} props.item Added to `data-item` attribute and is the object collected and used in final action\n * @yields {Element} A select field\n */\nfunction TextButton({ text, index, array, title, name, item }) {\n  /**\n   * Style selection according to props.position to add rounded corners as\n   * necessary to render grouped elements\n   *\n   * @member {string}\n   */\n  let position;\n  switch(index) {\n    case 0:\n      position = \"top\";\n      break;\n    case (array.length - 1):\n      position = \"bottom\";\n      break;\n    default:\n      position = \"center\";\n  }\n  if (array.length === 1) position = \"single\";\n  let borders = \"ba\";\n  if (position === \"top\") borders = \"br bl bt bb-0 br2 br--top\";\n  if (position === \"center\") borders = \"bl br bb-0 bt-0 br--top br2 br--top br--bottom\";\n  if (position === \"bottom\") borders = \"br bl bb bt-0 br2 br--bottom\";\n  if (position === \"single\") borders = \"ba br2\";\n\n  const slug = text.replace(/ /g, '-');\n  const type = (name === \"selectDate\") ? \"ttu tracked\" : \"\";\n\n  return (\n    <button\n      class={`w-100 f6 ${type} outline-0 dark-gray b--gray ${borders} bg-transparent pointer pa0`}\n      title={text}\n      name={slug}\n      id={slug}\n      type=\"button\"\n      >\n        <div\n          name={name}\n          class=\"dim bg-animate hover-bg-near-white pa1\"\n          data-item={item}\n          data-title={text}\n        >\n          { text }\n        </div>\n      </button>\n  );\n}\n\nexport default TextButton;\n\n"]}